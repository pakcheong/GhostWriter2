#!/usr/bin/env ts-node

import 'dotenv/config';
import fetch from 'node-fetch';
import { Command } from 'commander';
import fs from 'node:fs/promises';

type Article = {
  title: string;
  description: string;
  body: string; // markdown
  tags: string[];
  categories: string[];
  slug: string;
};

type Bundle = {
  provider: string;
  model: string;
  topic: string;
  count: number;
  items: Article[];
};

type WpTag = { id: number; name: string };
type WpCategory = { id: number; name: string };

const program = new Command();
program
  .name('publish-to-wp')
  .description('Publish generated articles to WordPress.')
  .requiredOption('--input <path>', 'Path to JSON generated by generate-content')
  .option('--wpBaseUrl <string>', 'WordPress REST base (e.g. https://site.com/wp-json/wp/v2)', process.env.WP_BASE_URL)
  .option('--wpUser <string>', 'WordPress username', process.env.WP_USERNAME)
  .option('--wpPass <string>', 'WordPress application password', process.env.WP_PASSWORD)
  .option('--status <publish|draft|pending>', 'Post status', 'publish')
  .parse(process.argv);

const opts = program.opts<{
  input: string;
  wpBaseUrl: string;
  wpUser: string;
  wpPass: string;
  status: 'publish' | 'draft' | 'pending';
}>();

function requireEnv(v: string | undefined, name: string): string {
  if (!v) throw new Error(`Missing ${name}. Provide via CLI or .env`);
  return v;
}

const WP_BASE = requireEnv(opts.wpBaseUrl, 'WP_BASE_URL');
const WP_USER = requireEnv(opts.wpUser, 'WP_USERNAME');
const WP_PASS = requireEnv(opts.wpPass, 'WP_PASSWORD');
const WP_AUTH = 'Basic ' + Buffer.from(`${WP_USER}:${WP_PASS}`).toString('base64');

async function wpGet<T = any>(path: string): Promise<T> {
  const res = await fetch(`${WP_BASE}${path}`, { headers: { Authorization: WP_AUTH } });
  if (!res.ok) throw new Error(`GET ${path} failed: ${res.status}`);
  return res.json() as Promise<T>;
}
async function wpPost<T = any>(path: string, body: any): Promise<T> {
  const res = await fetch(`${WP_BASE}${path}`, {
    method: 'POST',
    headers: { Authorization: WP_AUTH, 'Content-Type': 'application/json' },
    body: JSON.stringify(body)
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`POST ${path} failed: ${res.status} ${text}`);
  }
  return res.json() as Promise<T>;
}

function dedupe(arr: string[]): string[] {
  const s = new Set<string>();
  const out: string[] = [];
  for (const v of arr) {
    const k = v.trim();
    if (!s.has(k)) {
      s.add(k);
      out.push(k);
    }
  }
  return out;
}

async function ensureTags(tagNames: string[]): Promise<number[]> {
  if (!tagNames.length) return [];
  const existing = await wpGet<WpTag[]>('/tags?per_page=100');
  const ids: number[] = [];
  for (const name of dedupe(tagNames.map((x) => x.trim().toLowerCase()))) {
    const found = existing.find((t) => t.name.toLowerCase() === name);
    ids.push(found ? found.id : (await wpPost<WpTag>('/tags', { name })).id);
  }
  return ids;
}

async function ensureCategories(catNames: string[]): Promise<number[]> {
  if (!catNames.length) return [];
  const existing = await wpGet<WpCategory[]>('/categories?per_page=100');
  const ids: number[] = [];
  for (const name of dedupe(catNames.map((x) => x.trim().toLowerCase()))) {
    const found = existing.find((c) => c.name.toLowerCase() === name);
    ids.push(found ? found.id : (await wpPost<WpCategory>('/categories', { name })).id);
  }
  return ids;
}

async function publishOne(a: Article, status: 'publish' | 'draft' | 'pending') {
  const tagIds = await ensureTags(a.tags || []);
  const catIds = await ensureCategories(a.categories || []);
  const post = await wpPost('/posts', {
    title: a.title,
    content: a.body,
    excerpt: a.description,
    slug: a.slug,
    tags: tagIds,
    categories: catIds,
    status
  });
  console.log(`Published: ${post.link}`);
}

async function main() {
  const raw = await fs.readFile(opts.input, 'utf8');
  const bundle: Bundle = JSON.parse(raw);
  if (!bundle?.items?.length) throw new Error('No items found in input JSON.');
  for (const a of bundle.items) {
    await publishOne(a, opts.status);
  }
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
